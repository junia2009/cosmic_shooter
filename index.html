<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cosmic Shooter 3D</title>
  <style>
    body { margin: 0; overflow: hidden; background: #05081a; }
    #score {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-family: 'Orbitron', monospace;
      font-size: 2em;
      text-shadow: 0 0 10px #0ff, 0 0 20px #00f;
      z-index: 10;
    }
    #gameover {
      display: none;
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 2.5em;
      background: rgba(0,0,0,0.7);
      padding: 30px 50px;
      border-radius: 20px;
      text-align: center;
      z-index: 20;
    }
    #restartBtn {
      display: none;
      position: absolute;
      top: 75%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5em;
      padding: 15px 40px;
      background: #0ff;
      color: #111;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      z-index: 21;
    }
    #startScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100dvh;
      background: radial-gradient(ellipse at center,rgba(10,10,42,0.55) 60%,rgba(5,8,26,0.55) 100%);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #title3d {
      width: 420px;
      height: 180px;
    }
    .start-title {
      color: #fff;
      font-size: 2.6em;
      font-family: 'Orbitron', monospace;
      text-shadow: 0 0 18px #0ff, 0 0 30px #00f;
      margin-bottom: 30px;
    }
    .start-warning {
      color: #ff0;
      font-size: 1.3em;
      font-family: 'Orbitron', monospace;
      text-shadow: 0 0 10px #f80, 0 0 20px #ff0;
      margin-bottom: 18px;
    }
    #startBtn {
      font-size: 2em;
      padding: 18px 60px;
      background: #0ff;
      color: #111;
      border: none;
      border-radius: 16px;
      box-shadow: 0 0 18px #0ff;
      cursor: pointer;
    }
    .start-desc {
      margin-top: 40px;
      color: #fff;
      font-size: 1.1em;
      opacity: 0.7;
    }
    #timer {
      position: absolute;
      top: 20px;
      right: 40px;
      color: #fff;
      font-family: 'Orbitron', monospace;
      font-size: 2em;
      text-shadow: 0 0 10px #ff0, 0 0 20px #f80;
      z-index: 11;
    }
  </style>
</head>
<body>
  <audio id="startBgm" src="audio/space_pop.mp3" loop preload="auto"></audio>
  <audio id="playBgm" src="audio/cyber_attack.mp3" loop preload="auto"></audio>
  <div id="startScreen">
    <div class="start-flex">
      <div class="start-main">
        <div id="title3d"></div>
        <div class="start-title">COSMIC SHOOTER</div>
        <div class="start-warning">横画面でプレイしてください</div>
        <button id="startBtn">START</button>
        <div class="start-desc">画面タップ/クリックで移動・ショット</div>
      </div>
      <div class="howto-play">
        <b>【遊び方】</b><br>
        ・マウス・タッチ操作で自機を移動<br>
        ・クリック・タップ操作でショット<br>
        ・敵を倒してスコアを稼ごう！<br>
        ・アイテムを取ると効果発動：<br>
        　　<span class="item-bomb">●</span> 敵壊滅弾：画面内の敵を一掃<br>
        　　<span class="item-time">●</span> 時間プラス：残り時間+10秒<br>
        ・スコアに応じてランクが決まるよ！<br>
        <span class="howto-note">※スマホは横画面推奨</span>
      </div>
    </div>
    <style>
      .start-flex {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        justify-content: center;
        gap: 38px;
        width: 100vw;
        max-width: 100vw;
        box-sizing: border-box;
        padding: 0 2vw;
      }
      .start-main {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        min-width: 320px;
        max-width: 420px;
      }
      .howto-play {
        margin-top: 180px;
        padding: 18px 22px;
        background: rgba(0,0,0,0.45);
        border-radius: 14px;
        min-width: 260px;
        max-width: 340px;
        font-size: 1em;
        line-height: 1.6;
        text-align: left;
        box-shadow: 0 0 8px #0ff6;
        color: #fff;
        border: 1.5px solid #0ff;
        align-self: flex-start;
      }
      @media (max-width: 700px) {
        .start-flex {
          flex-direction: column;
          align-items: center;
          gap: 18px;
        }
        .howto-play {
          margin-top: 18px;
          min-width: 0;
          max-width: 98vw;
        }
      }
      .item-bomb {
        color: #ff0;
      }
      .item-time {
        color: #0ff;
      }
      .howto-note {
        font-size: 0.95em;
        color: #aaa;
      }
    </style>
  </div>
  <div id="score">0</div>
  <div id="timer">60</div>
  <div id="gameover">GAME OVER</div>
  <button id="restartBtn">リスタート</button>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
  import * as THREE from "three";
  import { FontLoader } from "three/addons/loaders/FontLoader.js";
  import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
  window.THREE = THREE;
  window.FontLoader = FontLoader;
  window.TextGeometry = TextGeometry;
    // --- 3D宇宙シューティングのベース ---
    let scene, camera, renderer, player, bullets = [], enemies = [], score = 0, isGameOver = false;
    let width = window.innerWidth, height = window.innerHeight;
    let playerTargetX = 0;
    let playerTargetY = 1.5;
    let gameStarted = false;
    // アイテム管理
    let items = [];
    const ITEM_TYPE = {
      BOMB: 0, // 敵壊滅弾
      TIME: 1  // 時間プラス
    };
    // --- スタート画面用3Dアニメーション ---
    let startScene, startCamera, startRenderer, startLogo, startStars = [], startAnimId;
        let startEnemies = [];
        // スタート画面リサイズ用（グローバル化）
        function resizeStartScreen() {
          let sw = window.innerWidth;
          let sh = window.innerHeight;
          if(window.visualViewport) sh = window.visualViewport.height;
          if(!startRenderer || !startCamera) return;
          startRenderer.setSize(sw, sh);
          startCamera.aspect = sw/sh;
          startCamera.updateProjectionMatrix();
        }

        // スタート画面アニメーション（グローバル化）
        function animateStart() {
          startAnimId = requestAnimationFrame(animateStart);
          if(startLogo) {
            startLogo.rotation.y += 0.025;
            startLogo.rotation.x += 0.01;
            startLogo.position.x = Math.sin(performance.now()*0.0007)*6;
            startLogo.position.y = Math.cos(performance.now()*0.0005)*2.5;
          }
          for(const s of startStars) {
            s.position.z += 0.22;
            if(s.position.z>10) s.position.z = -40;
          }
          // 敵も回転しながら広範囲に動かす
          for(const e of startEnemies) {
            if(e.type===2) e.obj.rotation.y += 0.07;
            else e.obj.rotation.y += 0.025;
            e.obj.position.x += Math.sin(performance.now()*0.0005+e.rot)*e.speed;
            e.obj.position.y += Math.cos(performance.now()*0.0007+e.rot)*e.speed*0.7;
            // 画面外に出たら戻す
            if(e.obj.position.x > 10) e.obj.position.x = -10;
            if(e.obj.position.x < -10) e.obj.position.x = 10;
            if(e.obj.position.y > 8) e.obj.position.y = 0.6;
            if(e.obj.position.y < 0.6) e.obj.position.y = 8;
          }
          if(startRenderer && startScene && startCamera) startRenderer.render(startScene, startCamera);
        }
    function showStartScreen() {
      // 3Dロゴ用Three.js
      // スタートBGM再生（自動再生はやめ、STARTボタンで再生）
      const startBgm = document.getElementById('startBgm');
      if(startBgm){
        startBgm.currentTime = 0;
        startBgm.volume = 0.7;
      }
      // スタート画面クリック/タップで一度だけBGM再生
      let startBgmPlayed = false;
      const playStartBgmOnce = () => {
        if(!startBgmPlayed && startBgm){
          startBgm.play().catch(()=>{});
          startBgmPlayed = true;
        }
      };
      const startScreen = document.getElementById('startScreen');
      if(startScreen){
        startScreen.addEventListener('pointerdown', playStartBgmOnce, { once: true });
      }
      // 画面全体に3Dアニメーションを表示
      startScene = new THREE.Scene();
      let sw = window.innerWidth, sh = window.innerHeight;
      startCamera = new THREE.PerspectiveCamera(60, sw/sh, 0.1, 100);
      startCamera.position.set(0,0,14);
      startRenderer = new THREE.WebGLRenderer({alpha:true,antialias:true});
      startRenderer.setSize(sw, sh);
      startRenderer.domElement.style.position = 'fixed';
      startRenderer.domElement.style.top = '0';
      startRenderer.domElement.style.left = '0';
      startRenderer.domElement.style.zIndex = '99';
      startRenderer.domElement.style.position = 'fixed';
      startRenderer.domElement.style.top = '0';
      startRenderer.domElement.style.left = '0';
      startRenderer.domElement.style.zIndex = '99';
      startRenderer.domElement.style.pointerEvents = 'none';
      document.body.appendChild(startRenderer.domElement);
      window.addEventListener('resize', resizeStartScreen);
      window.addEventListener('orientationchange', resizeStartScreen);
      window.removeEventListener('resize', resizeStartScreen);
      window.removeEventListener('orientationchange', resizeStartScreen);
      // --- 自機モデルをスタート画面用に生成 ---
      function createStartPlayer() {
        const group = new THREE.Group();
        // 本体
        const bodyMain = new THREE.Mesh(
          new THREE.BoxGeometry(1.3,0.9,2.1),
          new THREE.MeshStandardMaterial({color:0xff3333,metalness:0.7,roughness:0.15})
        );
        group.add(bodyMain);
        const bodySub = new THREE.Mesh(
          new THREE.BoxGeometry(0.9,0.7,1.2),
          new THREE.MeshStandardMaterial({color:0xffd700,metalness:0.7,roughness:0.18})
        );
        bodySub.position.z = 1.2;
        group.add(bodySub);
        const cockpit = new THREE.Mesh(
          new THREE.SphereGeometry(0.38, 18, 18),
          new THREE.MeshStandardMaterial({color:0x00bfff,metalness:0.5,roughness:0.1,transparent:true,opacity:0.7,emissive:0x00eaff})
        );
        cockpit.position.set(0,0,1.5);
        group.add(cockpit);
        const wingL = new THREE.Mesh(
          new THREE.BoxGeometry(0.22,1.2,0.55),
          new THREE.MeshStandardMaterial({color:0xffffff,metalness:0.8,roughness:0.13})
        );
        wingL.position.set(-0.75,0,0);
        wingL.rotation.z = Math.PI/10;
        group.add(wingL);
        const wingR = wingL.clone();
        wingR.position.x *= -1;
        wingR.rotation.z *= -1;
        group.add(wingR);
        const engine = new THREE.Mesh(
          new THREE.CylinderGeometry(0.22,0.22,0.55,14),
          new THREE.MeshStandardMaterial({color:0x3399ff,metalness:0.8,roughness:0.12,emissive:0x0033ff})
        );
        engine.position.set(0,0,-1.2);
        engine.rotation.x = Math.PI/2;
        group.add(engine);
        const deco1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.25,0.25,0.25),
          new THREE.MeshStandardMaterial({color:0xffff00,metalness:0.7,roughness:0.18})
        );
        deco1.position.set(-0.5,0.38,0);
        group.add(deco1);
        const deco2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.25,0.25,0.25),
          new THREE.MeshStandardMaterial({color:0x00ff99,metalness:0.7,roughness:0.18})
        );
        deco2.position.set(0.5,0.38,0);
        group.add(deco2);
        group.position.set(0,0,0);
        return group;
      }
      startLogo = createStartPlayer();
      startLogo.position.set(0,0,0);
      startScene.add(startLogo);
      // --- 敵を複数ランダム出現 ---
      startEnemies = [];
      function createStartEnemy(type) {
        const enemy = new THREE.Group();
        let colorMain = 0x2222ff, colorSub = 0xff3366, scale = 1, extra = null;
        if(type===0){
          const core = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 20, 20),
            new THREE.MeshStandardMaterial({color:colorMain,metalness:0.8,roughness:0.13,emissive:0x3366ff,emissiveIntensity:0.5})
          );
          enemy.add(core);
        }else if(type===1){
          colorMain = 0x00ffcc; colorSub = 0x00ffff; scale = 1.2;
          const stick = new THREE.Mesh(
            new THREE.CylinderGeometry(0.22,0.22,2.2,16),
            new THREE.MeshStandardMaterial({color:colorMain,metalness:0.7,roughness:0.18,emissive:colorSub,emissiveIntensity:0.7})
          );
          enemy.add(stick);
        }else if(type===2){
          colorMain = 0xff8800; colorSub = 0xffff00; scale = 1.1;
          const disk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.7,0.7,0.18,24),
            new THREE.MeshStandardMaterial({color:colorMain,metalness:0.8,roughness:0.13,emissive:colorSub,emissiveIntensity:0.7})
          );
          enemy.add(disk);
        }else{
          colorMain = 0xff44cc; colorSub = 0xffffff; scale = 0.6;
          const mini = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 14, 14),
            new THREE.MeshStandardMaterial({color:colorMain,metalness:0.7,roughness:0.18,emissive:colorSub,emissiveIntensity:0.7})
          );
          enemy.add(mini);
        }
        enemy.scale.set(scale,scale,scale);
        enemy.position.set((Math.random()-0.5)*7, (Math.random()-0.5)*2.5, -Math.random()*7-2);
        return enemy;
      }
      for(let i=0;i<12;i++){
        const t = Math.floor(Math.random()*4);
        const e = createStartEnemy(t);
        // より広範囲に配置
        e.position.set((Math.random()-0.5)*18, (Math.random()-0.5)*8, -Math.random()*18-2);
        startScene.add(e);
        startEnemies.push({obj:e, type:t, rot:Math.random()*Math.PI*2, speed:0.5+Math.random()*1.2});
      }
      // 星アニメ
      // 星を大幅増量＆広範囲に
      for(let i=0;i<220;i++){
        const star = new THREE.Mesh(
          new THREE.SphereGeometry(Math.random()*0.09+0.03,10,10),
          new THREE.MeshBasicMaterial({color:0xffffff})
        );
        star.position.set((Math.random()-0.5)*32, (Math.random()-0.5)*18, -Math.random()*40);
        startScene.add(star);
        startStars.push(star);
      }
      // ウィンドウリサイズ対応
      window.addEventListener('resize', resizeStartScreen);
      const light = new THREE.PointLight(0x00ffff,2.2,60);light.position.set(0,12,18);startScene.add(light);
      // アニメーション開始
      animateStart();
    }
    function hideStartScreen() {
      document.getElementById('startScreen').style.display = 'none';
      // スタートBGM停止
      const startBgm = document.getElementById('startBgm');
      if(startBgm){
        startBgm.pause();
        startBgm.currentTime = 0;
      }
      if(startAnimId) cancelAnimationFrame(startAnimId);
      // startStars, startEnemiesのThree.jsオブジェクトをシーンから削除
      if(startScene) {
        for(const s of startStars) startScene.remove(s);
        for(const e of startEnemies) startScene.remove(e.obj);
      }
      startStars = [];
      startEnemies = [];
      if(startRenderer) { startRenderer.dispose(); if(startRenderer.domElement.parentNode) startRenderer.domElement.parentNode.removeChild(startRenderer.domElement); }
      window.removeEventListener('resize', resizeStartScreen);
      startLogo = null;
      startScene = null;
      startCamera = null;
      startRenderer = null;
    }
    // スタート画面表示
    showStartScreen();
    document.getElementById('startBtn').onclick = function() {
      // スタートBGM停止
      const startBgm = document.getElementById('startBgm');
      if(startBgm){
        startBgm.pause();
        startBgm.currentTime = 0;
      }
      hideStartScreen();
      startGame();
    };
    function startGame() {
      gameStarted = true;
      // プレイBGM再生
      const playBgm = document.getElementById('playBgm');
      if(playBgm){
        playBgm.currentTime = 0;
        playBgm.volume = 0.7;
        playBgm.play().catch(()=>{});
      }
      init();
      animate();
    }
    // --- ここから下はゲーム本体 ---
    function init() {
            // 時間初期化
            window.gameTimeLimit = 60;
            window.gameTimeLeft = window.gameTimeLimit;
            document.getElementById('timer').textContent = window.gameTimeLeft;
            // アイテム配列初期化
            items = [];
            // アイテム出現タイマー（約7秒ごとにランダム出現）
            setInterval(()=>{
              if(!isGameOver && Math.random()<0.7) addItem();
            }, 7000);
            // タイマー処理
            window.timerInterval = setInterval(()=>{
              if(isGameOver) return;
              window.gameTimeLeft--;
              document.getElementById('timer').textContent = window.gameTimeLeft;
              if(window.gameTimeLeft<=0){
                isGameOver = true;
                // ランク計算
                let rank = 'D';
                if(score>=10000) rank='S';
                else if(score>=8000) rank='A';
                else if(score>=5000) rank='B';
                else if(score>=3000) rank='C';
                // スコアを大きく表示
                document.getElementById('gameover').innerHTML = '<div style="font-size:1.1em;margin-bottom:10px;">TIME UP!</div>'+
                  '<div style="font-size:2.2em;color:#ff0;text-shadow:0 0 18px #f80,0 0 30px #ff0;">Score: '+score+'</div>'+
                  '<div style="font-size:2em;margin-top:10px;color:#0ff;text-shadow:0 0 10px #0ff;">RANK: '+rank+'</div>';
                document.getElementById('gameover').style.display = 'block';
                document.getElementById('restartBtn').style.display = 'block';
                clearInterval(window.timerInterval);
              }
            },1000);
      // アイテム生成（グローバル化）
      function addItem(){
        // どちらかをランダムで出現
        const type = Math.random()<0.5 ? ITEM_TYPE.BOMB : ITEM_TYPE.TIME;
        // 形状・色分け＋アウトライン
        let mesh, outline;
        if(type===ITEM_TYPE.BOMB){
          // 敵壊滅弾: 赤球＋黄色リング＋星型＋発光
          mesh = new THREE.Group();
          // 中心の赤球
          const core = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 18, 18),
            new THREE.MeshStandardMaterial({color:0xff2222,emissive:0xffd700,emissiveIntensity:1.3,transparent:true,opacity:0.92})
          );
          mesh.add(core);
          // 黄色リング（回転）
          const ring = new THREE.Mesh(
            new THREE.TorusGeometry(0.45, 0.09, 16, 32),
            new THREE.MeshStandardMaterial({color:0xffff00,emissive:0xfff200,emissiveIntensity:1.1,transparent:true,opacity:0.7})
          );
          ring.rotation.x = Math.PI/2;
          mesh.add(ring);
          // 星型（五芒星）
          const starShape = new THREE.Shape();
          const R = 0.32, r = 0.13;
          for(let i=0;i<5;i++){
            const a = (Math.PI*2/5)*i-Math.PI/2;
            const x = Math.cos(a)*R, y = Math.sin(a)*R;
            if(i===0) starShape.moveTo(x,y); else starShape.lineTo(x,y);
            const a2 = a+Math.PI/5;
            starShape.lineTo(Math.cos(a2)*r, Math.sin(a2)*r);
          }
          const starGeo = new THREE.ShapeGeometry(starShape);
          const starMat = new THREE.MeshBasicMaterial({color:0xffff00, transparent:true, opacity:0.95, side:THREE.DoubleSide});
          const star = new THREE.Mesh(starGeo, starMat);
          star.position.z = 0.18;
          star.rotation.x = Math.PI/2;
          mesh.add(star);
          // 回転用フラグ
          mesh.userData = { ring, star };
        }else{
          // 時間プラス: 青いトーラス＋白発光＋白アウトライン
          mesh = new THREE.Mesh(
            new THREE.TorusGeometry(0.38, 0.13, 12, 24),
            new THREE.MeshStandardMaterial({color:0x33ccff,emissive:0xffffff,emissiveIntensity:1.1,transparent:true,opacity:0.92})
          );
          outline = new THREE.Mesh(
            new THREE.TorusGeometry(0.44, 0.18, 12, 24),
            new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.33, side:THREE.BackSide})
          );
          mesh.add(outline);
        }
        // ランダムな位置に出現（プレイヤーの近くには出さない）
        let x = (Math.random()-0.5)*16;
        let y = Math.random()*7+1;
        let z = -18-Math.random()*10;
        mesh.position.set(x, y, z);
        mesh.userData = {type};
        scene.add(mesh);
        items.push(mesh);
      }
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x05081a);
      // 星屑
        // 星屑を大幅に増やし、広範囲に分布
        for(let i=0;i<700;i++){
        const star = new THREE.Mesh(
          new THREE.SphereGeometry(Math.random()*0.13+0.04,10,10),
          new THREE.MeshBasicMaterial({color:0xffffff})
        );
          star.position.set((Math.random()-0.5)*80, (Math.random()-0.5)*45, -Math.random()*180-10);
        scene.add(star);
      }
      camera = new THREE.PerspectiveCamera(70, width/height, 0.1, 2000);
      camera.position.set(0,3,13);
      camera.lookAt(0,1.5,0);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(width, height);
      document.body.appendChild(renderer.domElement);
      // ライト
      scene.add(new THREE.AmbientLight(0x99ccff, 0.7));
      const dir = new THREE.DirectionalLight(0xffffff, 1.2);
      dir.position.set(5, 10, 10);
      scene.add(dir);
      // --- グミシップ風・ヒーロー機体（スケールアップ） ---
      player = new THREE.Group();
      // 本体
      const bodyMain = new THREE.Mesh(
        new THREE.BoxGeometry(1.3,0.9,2.1),
        new THREE.MeshStandardMaterial({color:0xff3333,metalness:0.7,roughness:0.15})
      );
      player.add(bodyMain);
      const bodySub = new THREE.Mesh(
        new THREE.BoxGeometry(0.9,0.7,1.2),
        new THREE.MeshStandardMaterial({color:0xffd700,metalness:0.7,roughness:0.18})
      );
      bodySub.position.z = 1.2;
      player.add(bodySub);
      // コックピット
      const cockpit = new THREE.Mesh(
        new THREE.SphereGeometry(0.38, 18, 18),
        new THREE.MeshStandardMaterial({color:0x00bfff,metalness:0.5,roughness:0.1,transparent:true,opacity:0.7,emissive:0x00eaff})
      );
      cockpit.position.set(0,0,1.5);
      player.add(cockpit);
      // サイドウィング
      const wingL = new THREE.Mesh(
        new THREE.BoxGeometry(0.22,1.2,0.55),
        new THREE.MeshStandardMaterial({color:0xffffff,metalness:0.8,roughness:0.13})
      );
      wingL.position.set(-0.75,0,0);
      wingL.rotation.z = Math.PI/10;
      player.add(wingL);
      const wingR = wingL.clone();
      wingR.position.x *= -1;
      wingR.rotation.z *= -1;
      player.add(wingR);
      // エンジン
      const engine = new THREE.Mesh(
        new THREE.CylinderGeometry(0.22,0.22,0.55,14),
        new THREE.MeshStandardMaterial({color:0x3399ff,metalness:0.8,roughness:0.12,emissive:0x0033ff})
      );
      engine.position.set(0,0,-1.2);
      engine.rotation.x = Math.PI/2;
      player.add(engine);
      // ディテール
      const deco1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.25,0.25,0.25),
        new THREE.MeshStandardMaterial({color:0xffff00,metalness:0.7,roughness:0.18})
      );
      deco1.position.set(-0.5,0.38,0);
      player.add(deco1);
      const deco2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.25,0.25,0.25),
        new THREE.MeshStandardMaterial({color:0x00ff99,metalness:0.7,roughness:0.18})
      );
      deco2.position.set(0.5,0.38,0);
      player.add(deco2);
      // 配置
      player.position.set(0,1.5,0);
      scene.add(player);
      // イベント
        // ステージ範囲を大幅拡大
        window.addEventListener('keydown',e=>{
          if(isGameOver)return;
          if(e.code==='ArrowLeft' && playerTargetX>-10)playerTargetX-=1.2;
          if(e.code==='ArrowRight' && playerTargetX<10)playerTargetX+=1.2;
          if(e.code==='ArrowUp' && playerTargetY<8)playerTargetY+=0.8;
          if(e.code==='ArrowDown' && playerTargetY>0.6)playerTargetY-=0.8;
          if(e.code==='Space')shoot();
        });
        // --- タッチ操作対応（スマホ） ---
        let touchStartX = null, touchStartY = null;
        let touchPlayerStartX = null, touchPlayerStartY = null;
        // --- マウス操作対応（PC） ---
        let mouseDown = false;
        let mouseStartX = null, mouseStartY = null;
        let mousePlayerStartX = null, mousePlayerStartY = null;
        window.addEventListener('mousedown', function(e) {
          if(isGameOver) return;
          mouseDown = true;
          mouseStartX = e.clientX;
          mouseStartY = e.clientY;
          mousePlayerStartX = playerTargetX;
          mousePlayerStartY = playerTargetY;
        });
        window.addEventListener('mousemove', function(e) {
          if(isGameOver) return;
          if(mouseDown && mouseStartX !== null && mouseStartY !== null) {
            // 横方向は画面幅20にマッピング（5倍反応）
            const dx = (e.clientX - mouseStartX) / window.innerWidth * 20 * 2;
            // 縦方向は画面高8にマッピング（5倍反応・逆方向）
            const dy = -(e.clientY - mouseStartY) / window.innerHeight * 8 * 2;
            let newX = mousePlayerStartX + dx;
            let newY = mousePlayerStartY + dy;
            // 範囲制限
            newX = Math.max(-10, Math.min(10, newX));
            newY = Math.max(0.6, Math.min(8, newY));
            playerTargetX = newX;
            playerTargetY = newY;
          }
        });
        window.addEventListener('mouseup', function(e) {
          if(isGameOver) return;
          mouseDown = false;
        });
        // クリックで弾発射
        window.addEventListener('click', function(e) {
          if(isGameOver) return;
          // UIボタン等は除外
          if(e.target === document.body || e.target === renderer.domElement) {
            shoot();
          }
        });
        window.addEventListener('touchstart', function(e) {
          if(isGameOver) return;
          if(e.touches.length === 1) {
            const t = e.touches[0];
            touchStartX = t.clientX;
            touchStartY = t.clientY;
            touchPlayerStartX = playerTargetX;
            touchPlayerStartY = playerTargetY;
          }
        });
        window.addEventListener('touchmove', function(e) {
          if(isGameOver) return;
          if(e.touches.length === 1 && touchStartX !== null && touchStartY !== null) {
            const t = e.touches[0];
            // 横方向は画面幅20にマッピング（5倍反応）
            const dx = (t.clientX - touchStartX) / window.innerWidth * 20 * 5;
            // 縦方向は画面高8にマッピング（5倍反応・逆方向）
            const dy = -(t.clientY - touchStartY) / window.innerHeight * 8 * 5;
            let newX = touchPlayerStartX + dx;
            let newY = touchPlayerStartY + dy;
            // 範囲制限
            newX = Math.max(-10, Math.min(10, newX));
            newY = Math.max(0.6, Math.min(8, newY));
            playerTargetX = newX;
            playerTargetY = newY;
          }
        });
        window.addEventListener('touchend', function(e) {
          if(isGameOver) return;
          // タップ（短いタッチ）で弾発射
          if(e.changedTouches.length === 1 && touchStartX !== null && touchStartY !== null) {
            // タップ移動量が小さい場合のみ発射
            const t = e.changedTouches[0];
            const dx = Math.abs(t.clientX - touchStartX);
            const dy = Math.abs(t.clientY - touchStartY);
            if(dx < 15 && dy < 15) {
              shoot();
            }
          }
          touchStartX = null; touchStartY = null;
        });
      // UI
      document.getElementById('score').textContent = '0';
      document.getElementById('gameover').style.display = 'none';
      document.getElementById('restartBtn').style.display = 'none';
      document.getElementById('restartBtn').onclick = ()=>location.reload();
      // 敵生成
      // 敵の出現頻度を大幅アップ（約0.7秒ごと）
      setInterval(()=>{if(!isGameOver)addEnemy();},700);
      // さらに初期化時に数体まとめて出現
      for(let i=0;i<4;i++) addEnemy();
    }
    function shoot(){
      // --- スケールアップした発光弾 ---
      // --- 幅広ビーム弾 ---
        // --- 細い球体ビーム弾（元に戻す） ---
        const bullet = new THREE.Mesh(
          new THREE.SphereGeometry(0.32, 18, 18),
          new THREE.MeshStandardMaterial({color:0xffff33,emissive:0xffff99,emissiveIntensity:1.0,transparent:true,opacity:0.85})
        );
        bullet.position.copy(player.position);
        // 弾道エフェクト（光の尾）
        const trail = new THREE.Mesh(
          new THREE.CylinderGeometry(0.16,0.22,1.2,12),
          new THREE.MeshStandardMaterial({color:0xffff99,emissive:0xffff99,emissiveIntensity:0.7,transparent:true,opacity:0.5})
        );
        trail.position.set(0,0,-0.6);
        trail.rotation.x = Math.PI/2;
        bullet.add(trail);
        scene.add(bullet);
        bullets.push(bullet);
    }
    function addEnemy(){
      // --- 敵バリエーション ---
      const type = Math.floor(Math.random()*4); // 0:球体, 1:棒, 2:円盤, 3:小型
      const enemy = new THREE.Group();
      let colorMain = 0x2222ff, colorSub = 0xff3366, y = null, scale = 1, speed = 7.25, extra = null;
      let shadow = null;
      // Y座標を広範囲ランダム化（全体空間に出現）
      y = Math.random()*7.4 + 0.6; // -2〜12の範囲で上下に広く出現
      if(type===0){
        // 球体型（既存）
        const core = new THREE.Mesh(
          new THREE.SphereGeometry(0.6, 20, 20),
          new THREE.MeshStandardMaterial({color:colorMain,metalness:0.8,roughness:0.13,emissive:0x3366ff,emissiveIntensity:0.5})
        );
        enemy.add(core);
        // シャドウ
        shadow = new THREE.Mesh(
          new THREE.CircleGeometry(0.55, 18),
          new THREE.MeshBasicMaterial({color:0x000000, opacity:0.22, transparent:true})
        );
        shadow.rotation.x = -Math.PI/2;
        shadow.position.y = -0.65;
        enemy.add(shadow);
        const glow = new THREE.Mesh(
          new THREE.SphereGeometry(0.28, 14, 14),
          new THREE.MeshStandardMaterial({color:colorSub,emissive:colorSub,emissiveIntensity:0.9,transparent:true,opacity:0.7})
        );
        glow.position.z = 0.22;
        enemy.add(glow);
        const wingL = new THREE.Mesh(
          new THREE.BoxGeometry(0.15,0.9,0.32),
          new THREE.MeshStandardMaterial({color:0xffffff,metalness:0.7,roughness:0.18})
        );
        wingL.position.set(-0.6,0,0);
        wingL.rotation.z = Math.PI/8;
        enemy.add(wingL);
        const wingR = wingL.clone();
        wingR.position.x *= -1;
        wingR.rotation.z *= -1;
        enemy.add(wingR);
        const thrusterObj = new THREE.Mesh(
          new THREE.CylinderGeometry(0.13,0.13,0.32,12),
          new THREE.MeshStandardMaterial({color:0xffd700,metalness:0.8,roughness:0.18,emissive:0xffd700})
        );
        thrusterObj.position.set(0,-0.6,0);
        thrusterObj.rotation.x = Math.PI/2;
        enemy.add(thrusterObj);
      }else if(type===1){
        // 棒型（縦長）
        colorMain = 0x00ffcc; colorSub = 0x00ffff; scale = 1.2;
        const stick = new THREE.Mesh(
          new THREE.CylinderGeometry(0.22,0.22,2.2,16),
          new THREE.MeshStandardMaterial({color:colorMain,metalness:0.7,roughness:0.18,emissive:colorSub,emissiveIntensity:0.7})
        );
        enemy.add(stick);
        // シャドウ
        shadow = new THREE.Mesh(
          new THREE.CircleGeometry(0.32, 16),
          new THREE.MeshBasicMaterial({color:0x000000, opacity:0.18, transparent:true})
        );
        shadow.rotation.x = -Math.PI/2;
        shadow.position.y = -1.2;
        enemy.add(shadow);
        const cap1 = new THREE.Mesh(
          new THREE.SphereGeometry(0.28, 12, 12),
          new THREE.MeshStandardMaterial({color:colorSub,emissive:colorSub,emissiveIntensity:0.7,transparent:true,opacity:0.7})
        );
        cap1.position.y = 1.1;
        enemy.add(cap1);
        const cap2 = cap1.clone();
        cap2.position.y = -1.1;
        enemy.add(cap2);
        speed = 5.5;
      }else if(type===2){
        // 円盤型（回転）
        colorMain = 0xff8800; colorSub = 0xffff00; scale = 1.1;
        const disk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.7,0.7,0.18,24),
          new THREE.MeshStandardMaterial({color:colorMain,metalness:0.8,roughness:0.13,emissive:colorSub,emissiveIntensity:0.7})
        );
        enemy.add(disk);
        // シャドウ
        shadow = new THREE.Mesh(
          new THREE.CircleGeometry(0.55, 18),
          new THREE.MeshBasicMaterial({color:0x000000, opacity:0.18, transparent:true})
        );
        shadow.rotation.x = -Math.PI/2;
        shadow.position.y = -0.13;
        enemy.add(shadow);
        const core = new THREE.Mesh(
          new THREE.SphereGeometry(0.22, 14, 14),
          new THREE.MeshStandardMaterial({color:colorSub,emissive:colorSub,emissiveIntensity:0.8,transparent:true,opacity:0.7})
        );
        core.position.z = 0.1;
        enemy.add(core);
        extra = 'spin';
        speed = 6.2;
      }else{
        // 小型高速型
        colorMain = 0xff44cc; colorSub = 0xffffff; scale = 0.6;
        const mini = new THREE.Mesh(
          new THREE.SphereGeometry(0.32, 14, 14),
          new THREE.MeshStandardMaterial({color:colorMain,metalness:0.7,roughness:0.18,emissive:colorSub,emissiveIntensity:0.7})
        );
        enemy.add(mini);
        // シャドウ
        shadow = new THREE.Mesh(
          new THREE.CircleGeometry(0.18, 12),
          new THREE.MeshBasicMaterial({color:0x000000, opacity:0.15, transparent:true})
        );
        shadow.rotation.x = -Math.PI/2;
        shadow.position.y = -0.33;
        enemy.add(shadow);
        speed = 11.5;
        // 小型も同じ範囲で出現
        y = -2 + Math.random()*14;
      }
      // 配置
      const z = -35 - Math.random()*4;
      let ex = (Math.random()-0.5)*20;
      if(ex > 10) ex = 10;
      if(ex < -10) ex = -10;
      enemy.position.set(ex, y, z);
      enemy.scale.set(scale,scale,scale);
      enemy.userData = {type, speed, extra};
      scene.add(enemy);
      enemies.push(enemy);
    }
    function animate(){
      // --- deltaTimeでぬるぬる制御 ---
      let prevTime = animate.prevTime || performance.now();
      const now = performance.now();
      const delta = Math.min((now - prevTime) * 0.001, 0.05); // 秒
      animate.prevTime = now;
      requestAnimationFrame(animate);
      if(!isGameOver){
        // 自機ぬるぬる移動（X・Y両軸）
        if(player){
          player.position.x = playerTargetX;
          player.position.y = playerTargetY;
        }
        // タイムアップ時の即時終了
        if(window.gameTimeLeft<=0){
          isGameOver = true;
          // ランク計算（スコアのみ・新基準）
          let rank = 'D';
          if(score>=10000) rank='S';
          else if(score>=8000) rank='A';
          else if(score>=5000) rank='B';
          else if(score>=3000) rank='C';
          document.getElementById('gameover').innerHTML = '<div style="font-size:1.1em;margin-bottom:10px;">TIME UP!</div>'+
            '<div style="font-size:2.2em;color:#ff0;text-shadow:0 0 18px #f80,0 0 30px #ff0;">Score: '+score+'</div>'+
            '<div style="font-size:2em;margin-top:10px;color:#0ff;text-shadow:0 0 10px #0ff;">RANK: '+rank+'</div>';
          document.getElementById('gameover').style.display = 'block';
          document.getElementById('restartBtn').style.display = 'block';
          return;
        }
        // 弾移動（超高速化）
        for(let i=bullets.length-1;i>=0;i--){
          bullets[i].position.z-=35*delta;
          if(bullets[i].position.z<-40){scene.remove(bullets[i]);bullets.splice(i,1);}
        }
        // 敵移動＆挙動
        for(let i=enemies.length-1;i>=0;i--){
          const e = enemies[i];
          const t = e.userData.type;
          const speed = e.userData.speed || 7.25;
          e.position.z += speed*delta;
          // 円盤型は回転
          if(e.userData.extra==='spin'){
            e.rotation.y += 2.5*delta;
          }
          // 衝突判定
          for(let j=bullets.length-1;j>=0;j--){
            let hitDist = 1.25;
            if(t===1) hitDist=1.45; // 棒型
            if(t===2) hitDist=1.55; // 円盤型
            if(t===3) hitDist=0.95; // 小型
            if(e.position.distanceTo(bullets[j].position)<hitDist){
              // --- 爆発アニメーション ---
              const explosionParticles = [];
              const explosionGroup = new THREE.Group();
              const explosionColor = [0xfff200, 0xff6600, 0xff2222, 0xffffff];
              for(let p=0;p<18;p++){
                const mat = new THREE.MeshStandardMaterial({
                  color: explosionColor[Math.floor(Math.random()*explosionColor.length)],
                  emissive: 0xffa500,
                  emissiveIntensity: 0.7,
                  transparent: true,
                  opacity: 0.85
                });
                const geo = new THREE.SphereGeometry(Math.random()*0.13+0.09, 8, 8);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(e.position);
                // ランダムな方向ベクトル
                mesh.userData = {
                  velocity: new THREE.Vector3(
                    (Math.random()-0.5)*2.7,
                    (Math.random()-0.5)*2.7,
                    (Math.random()-0.5)*2.7
                  ),
                  life: 0.45+Math.random()*0.18
                };
                explosionGroup.add(mesh);
                explosionParticles.push(mesh);
              }
              scene.add(explosionGroup);
              // 爆発アニメーション用リストをwindowに保持
              if(!window.explosions) window.explosions = [];
              window.explosions.push({group: explosionGroup, particles: explosionParticles, time: 0});

              scene.remove(e);enemies.splice(i,1);
              scene.remove(bullets[j]);bullets.splice(j,1);
              // 敵タイプごとにスコア
              let addScore = 100;
              if(t===1) addScore=150;
              else if(t===2) addScore=200;
              else if(t===3) addScore=80;
              score+=addScore;
              document.getElementById('score').textContent=score;
              break;
            }
          }
          // プレイヤーと敵
          let playerDist = 1.3;
          if(t===1) playerDist=1.45;
          if(t===2) playerDist=1.55;
          if(t===3) playerDist=0.95;
          if(e&&e.position.distanceTo(player.position)<playerDist){
            isGameOver=true;
            // ランク計算（スコアのみ・新基準）
              let rank = 'D';
            if(score>=10000) rank='S';
            else if(score>=8000) rank='A';
            else if(score>=5000) rank='B';
            else if(score>=3000) rank='C';
            else rank='D';
            document.getElementById('gameover').innerHTML = '<div style="font-size:1.1em;margin-bottom:10px;">GAME OVER</div>'+
              '<div style="font-size:2.2em;color:#ff0;text-shadow:0 0 18px #f80,0 0 30px #ff0;">Score: '+score+'</div>'+
              '<div style="font-size:2em;margin-top:10px;color:#0ff;text-shadow:0 0 10px #0ff;">RANK: '+rank+'</div>';
            document.getElementById('gameover').style.display='block';
            document.getElementById('restartBtn').style.display='block';
          }
          if(e&&e.position.z>10){scene.remove(e);enemies.splice(i,1);}
        }
      }
      // --- 爆発アニメーションの更新 ---
      if(window.explosions){
        for(let k=window.explosions.length-1;k>=0;k--){
          const exp = window.explosions[k];
          exp.time += delta;
          for(const mesh of exp.particles){
            mesh.position.addScaledVector(mesh.userData.velocity, delta*2.5);
            mesh.material.opacity -= delta*2.2;
            if(mesh.material.opacity<0) mesh.material.opacity=0;
          }
          // 一定時間経過で削除
          if(exp.time > 0.55){
            scene.remove(exp.group);
            window.explosions.splice(k,1);
          }
        }
      }
      // ゲームオーバー時にBGM停止
      if(isGameOver){
        const playBgm = document.getElementById('playBgm');
        if(playBgm && !playBgm.paused){
          playBgm.pause();
          playBgm.currentTime = 0;
        }
      }
      // アイテムの移動・描画・取得判定
      for(let i=items.length-1;i>=0;i--){
        const item = items[i];
        // 浮遊アニメ
        item.position.z += 7*delta;
        item.position.y += Math.sin(performance.now()*0.002+item.position.x)*0.012;
        // 回転アニメ
        item.rotation.y += 1.5*delta;
        item.rotation.x += 0.7*delta;
        // 敵壊滅弾の特殊アニメ
        if(item.userData && item.userData.ring && item.userData.star){
          item.userData.ring.rotation.z += 2.5*delta;
          item.userData.star.rotation.z += 0.7*delta;
        }
        // 画面外で消去
        if(item.position.z>10){
          scene.remove(item); items.splice(i,1);
          continue;
        }
        // プレイヤー取得判定
        if(player && item.position.distanceTo(player.position)<1.1){
          // 敵壊滅弾
          if(item.userData.type === ITEM_TYPE.BOMB){
            // 全敵爆発エフェクト＆消去＋スコア加算
            for(let k=enemies.length-1;k>=0;k--){
              const e = enemies[k];
              const t = e.userData.type;
              // 爆発エフェクト（既存流用）
              const explosionParticles = [];
              const explosionGroup = new THREE.Group();
              const explosionColor = [0xfff200, 0xff6600, 0xff2222, 0xffffff];
              for(let p=0;p<12;p++){
                const mat = new THREE.MeshStandardMaterial({
                  color: explosionColor[Math.floor(Math.random()*explosionColor.length)],
                  emissive: 0xffa500,
                  emissiveIntensity: 0.7,
                  transparent: true,
                  opacity: 0.85
                });
                const geo = new THREE.SphereGeometry(Math.random()*0.13+0.09, 8, 8);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(e.position);
                mesh.userData = {
                  velocity: new THREE.Vector3(
                    (Math.random()-0.5)*2.7,
                    (Math.random()-0.5)*2.7,
                    (Math.random()-0.5)*2.7
                  ),
                  life: 0.45+Math.random()*0.18
                };
                explosionGroup.add(mesh);
                explosionParticles.push(mesh);
              }
              scene.add(explosionGroup);
              if(!window.explosions) window.explosions = [];
              window.explosions.push({group: explosionGroup, particles: explosionParticles, time: 0});
              // スコア加算（敵タイプごと）
              let addScore = 100;
              if(t===1) addScore=150;
              else if(t===2) addScore=200;
              else if(t===3) addScore=80;
              score+=addScore;
              document.getElementById('score').textContent=score;
              scene.remove(e);
            }
            enemies.length = 0;
          }
          // 時間プラス
          if(item.userData.type === ITEM_TYPE.TIME){
            window.gameTimeLeft += 10;
            // 最大値制限（例: 99秒）
            if(window.gameTimeLeft>99) window.gameTimeLeft=99;
            document.getElementById('timer').textContent = window.gameTimeLeft;
            // エフェクト: 一瞬光る球体
            const eff = new THREE.Mesh(
              new THREE.SphereGeometry(0.7, 18, 18),
              new THREE.MeshStandardMaterial({color:0x00ffff,emissive:0xffff99,emissiveIntensity:1.2,transparent:true,opacity:0.7})
            );
            eff.position.copy(player.position);
            scene.add(eff);
            setTimeout(()=>{scene.remove(eff);}, 350);
          }
          // アイテム消去
          scene.remove(item); items.splice(i,1);
        }
      }
      renderer.render(scene,camera);
    }
    window.addEventListener('resize',()=>{
      width = window.innerWidth;
      height = window.innerHeight;
      if(window.visualViewport) height = window.visualViewport.height;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
  });

  // orientationchangeにも対応
    window.addEventListener('orientationchange', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      if(window.visualViewport) height = window.visualViewport.height;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });
    // ゲーム本体はstartGame()からのみ開始
  </script>
</body>
</html>
